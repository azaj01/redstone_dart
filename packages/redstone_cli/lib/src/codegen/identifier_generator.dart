import 'dart:io';

import 'package:path/path.dart' as p;

import '../project/redstone_project.dart';

/// Generates type-safe Dart identifiers from asset files.
class IdentifierGenerator {
  final RedstoneProject project;

  IdentifierGenerator(this.project);

  Future<void> generate() async {
    final blockTextures = await _scanTextures('block');
    final itemTextures = await _scanTextures('item');

    final code = _generateCode(blockTextures, itemTextures);

    // Write to lib/generated/textures.dart
    final outputDir = Directory(p.join(project.rootDir, 'lib', 'generated'));
    if (!outputDir.existsSync()) {
      outputDir.createSync(recursive: true);
    }

    final outputFile = File(p.join(outputDir.path, 'textures.dart'));
    await outputFile.writeAsString(code);
  }

  /// Scan textures in assets/textures/{type}/ and return list of (name, path) pairs
  Future<List<(String, String)>> _scanTextures(String type) async {
    final dir = Directory(p.join(project.assetsDir, 'textures', type));
    if (!dir.existsSync()) return [];

    final textures = <(String, String)>[];

    await for (final entity in dir.list(recursive: false)) {
      if (entity is File && entity.path.endsWith('.png')) {
        final fileName = p.basenameWithoutExtension(entity.path);
        final relativePath = 'assets/textures/$type/$fileName.png';
        textures.add((fileName, relativePath));
      }
    }

    // Sort alphabetically
    textures.sort((a, b) => a.$1.compareTo(b.$1));
    return textures;
  }

  String _generateCode(
    List<(String, String)> blockTextures,
    List<(String, String)> itemTextures,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by `redstone generate`');
    buffer.writeln('');
    buffer.writeln('// ignore_for_file: constant_identifier_names');
    buffer.writeln('');

    // Generate BlockTextures class
    buffer.writeln('/// Block textures found in assets/textures/block/');
    buffer.writeln('abstract final class BlockTextures {');
    buffer.writeln('  BlockTextures._();');
    buffer.writeln('');
    for (final (name, path) in blockTextures) {
      final fieldName = _snakeToCamelCase(name);
      buffer.writeln("  static const $fieldName = '$path';");
    }
    buffer.writeln('}');
    buffer.writeln('');

    // Generate ItemTextures class
    buffer.writeln('/// Item textures found in assets/textures/item/');
    buffer.writeln('abstract final class ItemTextures {');
    buffer.writeln('  ItemTextures._();');
    buffer.writeln('');
    for (final (name, path) in itemTextures) {
      final fieldName = _snakeToCamelCase(name);
      buffer.writeln("  static const $fieldName = '$path';");
    }
    buffer.writeln('}');
    buffer.writeln('');

    // Generate BlockIds class (from block textures - assumes 1:1 mapping)
    buffer.writeln('/// Block IDs derived from block textures.');
    buffer.writeln('/// Use these when defining CustomBlock.id');
    buffer.writeln('abstract final class BlockIds {');
    buffer.writeln('  BlockIds._();');
    buffer.writeln('');
    for (final (name, _) in blockTextures) {
      final fieldName = _snakeToCamelCase(name);
      final snakeName = name; // Already snake_case from filename
      buffer.writeln("  static const $fieldName = '${project.name}:$snakeName';");
    }
    buffer.writeln('}');
    buffer.writeln('');

    // Generate ItemIds class (from item textures)
    buffer.writeln('/// Item IDs derived from item textures.');
    buffer.writeln('/// Use these when defining CustomItem.id');
    buffer.writeln('abstract final class ItemIds {');
    buffer.writeln('  ItemIds._();');
    buffer.writeln('');
    for (final (name, _) in itemTextures) {
      final fieldName = _snakeToCamelCase(name);
      final snakeName = name;
      buffer.writeln("  static const $fieldName = '${project.name}:$snakeName';");
    }
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Convert snake_case to camelCase
  String _snakeToCamelCase(String snake) {
    final parts = snake.split('_');
    if (parts.isEmpty) return snake;

    final first = parts.first.toLowerCase();
    final rest = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return '${part[0].toUpperCase()}${part.substring(1).toLowerCase()}';
    }).join('');

    return '$first$rest';
  }
}
