package com.redstone.worldgen;

import net.fabricmc.fabric.api.biome.v1.BiomeModifications;
import net.fabricmc.fabric.api.biome.v1.BiomeSelectionContext;
import net.fabricmc.fabric.api.biome.v1.BiomeSelectors;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.Identifier;
import net.minecraft.tags.TagKey;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.levelgen.GenerationStep;
import net.minecraft.world.level.levelgen.placement.PlacedFeature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

/**
 * Registry for Dart-defined ore features for world generation.
 *
 * This registry works in conjunction with the Redstone CLI's datagen phase:
 *
 * 1. During `redstone build`, the CLI runs the Dart mod in datagen mode
 * 2. Dart code writes ore feature configs to .redstone/manifest.json
 * 3. CLI generates JSON files into src/main/resources/data/... which get bundled in the mod JAR
 * 4. At runtime, this class registers BiomeModifications to add the bundled features to biomes
 *
 * The JSON files (ConfiguredFeature, PlacedFeature) are generated at BUILD TIME by the CLI,
 * not at runtime. This is required because Minecraft's dynamic registries (worldgen features)
 * can only be loaded from JSON bundled with the mod, not generated at runtime.
 *
 * Ores can be configured with:
 * - Vein size and frequency
 * - Y-level distribution (uniform, triangle, trapezoid)
 * - Biome selection (overworld, nether, end, or biome tags)
 * - Deepslate variants with configurable transition Y-level
 */
public class OreFeatureRegistry {
    private static final Logger LOGGER = LoggerFactory.getLogger("OreFeatureRegistry");

    // Track registered features for debugging
    private static final Map<String, OreConfig> registeredOres = new HashMap<>();

    /**
     * Configuration record for ore generation.
     *
     * @param oreBlockId         Block ID of the ore (e.g., "mymod:ruby_ore")
     * @param veinSize           Max number of blocks per vein (e.g., 9 for iron)
     * @param veinsPerChunk      Average veins per chunk (e.g., 8)
     * @param minY               Minimum Y level (e.g., -64)
     * @param maxY               Maximum Y level (e.g., 64)
     * @param distributionType   Height distribution: "uniform", "triangle", or "trapezoid"
     * @param replaceableTag     Tag of blocks the ore can replace (e.g., "minecraft:stone_ore_replaceables")
     * @param biomeSelector      Biome filter: "overworld", "nether", "end", or tag like "#minecraft:is_overworld"
     * @param deepslateVariant   Optional deepslate variant block ID (e.g., "mymod:deepslate_ruby_ore")
     * @param deepslateTransitionY Y level where deepslate takes over (e.g., 0)
     */
    public record OreConfig(
        String oreBlockId,
        int veinSize,
        int veinsPerChunk,
        int minY,
        int maxY,
        String distributionType,
        String replaceableTag,
        String biomeSelector,
        String deepslateVariant,
        int deepslateTransitionY
    ) {}

    /**
     * Register an ore feature for world generation.
     *
     * IMPORTANT: This method assumes that the ConfiguredFeature and PlacedFeature JSON files
     * have already been generated by the CLI during the build phase and are bundled in the
     * mod's resources. This method only registers the BiomeModification to add the feature
     * to the appropriate biomes.
     *
     * The JSON files must exist at:
     * - data/{namespace}/worldgen/configured_feature/{path}.json
     * - data/{namespace}/worldgen/placed_feature/{path}.json
     *
     * @param namespace Mod namespace (e.g., "mymod")
     * @param path      Feature path (e.g., "ruby_ore_feature")
     * @param config    Ore configuration parameters
     */
    public static void registerOreFeature(String namespace, String path, OreConfig config) {
        try {
            String fullId = namespace + ":" + path;
            LOGGER.info("Registering ore feature: {} with config: {}", fullId, config);

            // Validate the ore block exists
            Identifier oreBlockId = Identifier.parse(config.oreBlockId());
            Block oreBlock = BuiltInRegistries.BLOCK.getValue(oreBlockId);

            if (oreBlock == null || oreBlock == BuiltInRegistries.BLOCK.getValue(BuiltInRegistries.BLOCK.getDefaultKey())) {
                LOGGER.error("Ore block not found in registry: {} - make sure the block is registered before the ore feature", config.oreBlockId());
                return;
            }

            // Store for debugging/introspection
            registeredOres.put(fullId, config);

            // Create a ResourceKey for the placed feature
            // The JSON file must exist at data/{namespace}/worldgen/placed_feature/{path}.json
            // and will be loaded by Minecraft's datapack system
            ResourceKey<PlacedFeature> placedFeatureKey = ResourceKey.create(
                Registries.PLACED_FEATURE,
                Identifier.parse(namespace + ":" + path)
            );

            // Get the biome selector based on the config
            Predicate<BiomeSelectionContext> biomeSelector = getBiomeSelector(config.biomeSelector());

            // Register a BiomeModification to add this feature to the selected biomes
            // This runs during world creation, after datapacks are loaded
            BiomeModifications.addFeature(
                biomeSelector,
                GenerationStep.Decoration.UNDERGROUND_ORES,
                placedFeatureKey
            );

            LOGGER.info("Successfully registered ore feature: {} (vein size: {}, veins/chunk: {}, Y: {}..{}, distribution: {})",
                fullId, config.veinSize(), config.veinsPerChunk(), config.minY(), config.maxY(), config.distributionType());
            LOGGER.info("BiomeModification registered for biomes: {}", config.biomeSelector());

        } catch (Exception e) {
            LOGGER.error("Failed to register ore feature {}:{}: {}", namespace, path, e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Get the biome selector predicate based on the selector string.
     */
    private static Predicate<BiomeSelectionContext> getBiomeSelector(String selectorString) {
        if (selectorString == null || selectorString.isEmpty()) {
            return BiomeSelectors.foundInOverworld();
        }

        return switch (selectorString.toLowerCase()) {
            case "overworld" -> BiomeSelectors.foundInOverworld();
            case "nether", "the_nether" -> BiomeSelectors.foundInTheNether();
            case "end", "the_end" -> BiomeSelectors.foundInTheEnd();
            default -> {
                if (selectorString.startsWith("#")) {
                    // It's a biome tag like "#minecraft:is_overworld"
                    String tagString = selectorString.substring(1);
                    Identifier tagId = Identifier.parse(tagString);
                    TagKey<net.minecraft.world.level.biome.Biome> biomeTag = TagKey.create(
                        Registries.BIOME,
                        tagId
                    );
                    yield BiomeSelectors.tag(biomeTag);
                } else {
                    // Default to overworld
                    LOGGER.warn("Unknown biome selector: {} - defaulting to overworld", selectorString);
                    yield BiomeSelectors.foundInOverworld();
                }
            }
        };
    }

    /**
     * Get all registered ore configurations for debugging.
     */
    public static Map<String, OreConfig> getRegisteredOres() {
        return new HashMap<>(registeredOres);
    }

    /**
     * Get the count of registered ore features.
     */
    public static int getOreCount() {
        return registeredOres.size();
    }
}
